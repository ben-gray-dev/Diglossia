"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const config_1 = require("@schematics/angular/utility/config");
const schematics_2 = require("@angular/cdk/schematics");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const terminal_1 = require("@angular-devkit/core/src/terminal");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
// tslint:disable-next-line:max-line-length
const package_setting_1 = require("../util/package-setting");
const npmjs_1 = require("../util/npmjs");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
// You don't have to export the function as default. You can also have more than one rule factory
// per file.
function ngAdd(options) {
    return (tree, context) => {
        return schematics_1.chain([
            addDependencies(package_setting_1.NGX_SPEECH_RECOGNITION_PACKAGE_NAME, dependencies_1.NodeDependencyType.Default),
            installDependencies(),
            addNgxFaceApiJsModule(options),
        ])(tree, context);
    };
}
exports.ngAdd = ngAdd;
function addDependencies(packageName, type) {
    return (host, context) => {
        const buf = host.read('package.json');
        if (!buf) {
            throw new schematics_1.SchematicsException('cannot find package.json');
        }
        return rxjs_1.of(packageName).pipe(operators_1.concatMap(name => npmjs_1.getLatestNodeVersion(name)), operators_1.map((npmRegistryPackage) => {
            const nodeDependency = {
                type,
                name: npmRegistryPackage.name,
                version: npmRegistryPackage.version,
                overwrite: false
            };
            dependencies_1.addPackageJsonDependency(host, nodeDependency);
            context.logger.info(`✅️ Added dependency: ${npmRegistryPackage.name}@${npmRegistryPackage.version}`);
            return host;
        }));
    };
}
exports.addDependencies = addDependencies;
function installDependencies() {
    return (host, context) => {
        context.addTask(new tasks_1.NodePackageInstallTask());
        context.logger.info('✅️ Dependencies installed');
        return host;
    };
}
function addNgxFaceApiJsModule(options) {
    return (host, context) => {
        const workspace = config_1.getWorkspace(host);
        const project = schematics_2.getProjectFromWorkspace(workspace, options.project);
        const appModulePath = ng_ast_utils_1.getAppModulePath(host, schematics_2.getProjectMainFile(project));
        if (schematics_2.hasNgModuleImport(host, appModulePath, package_setting_1.NGX_SPEECH_RECOGNITION_MODULE_NAME)) {
            return console.warn(terminal_1.red(`Could not set up "${terminal_1.bold(package_setting_1.NGX_SPEECH_RECOGNITION_MODULE_NAME)}" ` +
                `because "${terminal_1.bold(package_setting_1.NGX_SPEECH_RECOGNITION_MODULE_NAME)}" is already imported.`));
        }
        schematics_2.addModuleImportToRootModule(host, `${package_setting_1.NGX_SPEECH_RECOGNITION_MODULE_NAME}.forRoot({ lang: 'en-US' })`, package_setting_1.NGX_SPEECH_RECOGNITION_PACKAGE_NAME, project);
        context.logger.info(`✅️ ${package_setting_1.NGX_SPEECH_RECOGNITION_MODULE_NAME} Imported to ${appModulePath}`);
        return host;
    };
}
//# sourceMappingURL=index.js.map